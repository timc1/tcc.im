'use strict'
;(THREE.OrbitControls = function(a, b) {
  function c() {
    return ((2 * Math.PI) / 60 / 60) * I.autoRotateSpeed
  }
  function d() {
    return Math.pow(0.95, I.zoomSpeed)
  }
  function e(ea) {
    Q.theta -= ea
  }
  function f(ea) {
    Q.phi -= ea
  }
  function g(ea) {
    I.object.isPerspectiveCamera
      ? (R /= ea)
      : I.object.isOrthographicCamera
        ? ((I.object.zoom = Math.max(
            I.minZoom,
            Math.min(I.maxZoom, I.object.zoom * ea)
          )),
          I.object.updateProjectionMatrix(),
          (T = !0))
        : (console.warn(
            'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.'
          ),
          (I.enableZoom = !1))
  }
  function h(ea) {
    I.object.isPerspectiveCamera
      ? (R *= ea)
      : I.object.isOrthographicCamera
        ? ((I.object.zoom = Math.max(
            I.minZoom,
            Math.min(I.maxZoom, I.object.zoom / ea)
          )),
          I.object.updateProjectionMatrix(),
          (T = !0))
        : (console.warn(
            'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.'
          ),
          (I.enableZoom = !1))
  }
  function i(ea) {
    U.set(ea.clientX, ea.clientY)
  }
  function j(ea) {
    $.set(ea.clientX, ea.clientY)
  }
  function k(ea) {
    X.set(ea.clientX, ea.clientY)
  }
  function l(ea) {
    V.set(ea.clientX, ea.clientY),
      W.subVectors(V, U).multiplyScalar(I.rotateSpeed)
    var fa = I.domElement === document ? I.domElement.body : I.domElement
    e((2 * Math.PI * W.x) / fa.clientHeight),
      f((2 * Math.PI * W.y) / fa.clientHeight),
      U.copy(V),
      I.update()
  }
  function m(ea) {
    _.set(ea.clientX, ea.clientY),
      aa.subVectors(_, $),
      0 < aa.y ? g(d()) : 0 > aa.y && h(d()),
      $.copy(_),
      I.update()
  }
  function n(ea) {
    Y.set(ea.clientX, ea.clientY),
      Z.subVectors(Y, X).multiplyScalar(I.panSpeed),
      da(Z.x, Z.y),
      X.copy(Y),
      I.update()
  }
  function o() {}
  function p(ea) {
    0 > ea.deltaY ? h(d()) : 0 < ea.deltaY && g(d()), I.update()
  }
  function q(ea) {
    switch (ea.keyCode) {
      case I.keys.UP:
        da(0, I.keyPanSpeed), I.update()
        break
      case I.keys.BOTTOM:
        da(0, -I.keyPanSpeed), I.update()
        break
      case I.keys.LEFT:
        da(I.keyPanSpeed, 0), I.update()
        break
      case I.keys.RIGHT:
        da(-I.keyPanSpeed, 0), I.update()
    }
  }
  function r(ea) {
    U.set(ea.touches[0].pageX, ea.touches[0].pageY)
  }
  function s(ea) {
    if (I.enableZoom) {
      var fa = ea.touches[0].pageX - ea.touches[1].pageX,
        ga = ea.touches[0].pageY - ea.touches[1].pageY,
        ha = Math.sqrt(fa * fa + ga * ga)
      $.set(0, ha)
    }
    if (I.enablePan) {
      var ia = 0.5 * (ea.touches[0].pageX + ea.touches[1].pageX),
        ja = 0.5 * (ea.touches[0].pageY + ea.touches[1].pageY)
      X.set(ia, ja)
    }
  }
  function t(ea) {
    V.set(ea.touches[0].pageX, ea.touches[0].pageY),
      W.subVectors(V, U).multiplyScalar(I.rotateSpeed)
    var fa = I.domElement === document ? I.domElement.body : I.domElement
    e((2 * Math.PI * W.x) / fa.clientHeight),
      f((2 * Math.PI * W.y) / fa.clientHeight),
      U.copy(V),
      I.update()
  }
  function u(ea) {
    if (I.enableZoom) {
      var fa = ea.touches[0].pageX - ea.touches[1].pageX,
        ga = ea.touches[0].pageY - ea.touches[1].pageY,
        ha = Math.sqrt(fa * fa + ga * ga)
      _.set(0, ha),
        aa.set(0, Math.pow(_.y / $.y, I.zoomSpeed)),
        g(aa.y),
        $.copy(_)
    }
    if (I.enablePan) {
      var ia = 0.5 * (ea.touches[0].pageX + ea.touches[1].pageX),
        ja = 0.5 * (ea.touches[0].pageY + ea.touches[1].pageY)
      Y.set(ia, ja),
        Z.subVectors(Y, X).multiplyScalar(I.panSpeed),
        da(Z.x, Z.y),
        X.copy(Y)
    }
    I.update()
  }
  function w() {}
  function z(ea) {
    if (!1 !== I.enabled) {
      switch ((ea.preventDefault(), ea.button)) {
        case I.mouseButtons.LEFT:
          if (ea.ctrlKey || ea.metaKey) {
            if (!1 === I.enablePan) return
            k(ea), (N = M.PAN)
          } else {
            if (!1 === I.enableRotate) return
            i(ea), (N = M.ROTATE)
          }
          break
        case I.mouseButtons.MIDDLE:
          if (!1 === I.enableZoom) return
          j(ea), (N = M.DOLLY)
          break
        case I.mouseButtons.RIGHT:
          if (!1 === I.enablePan) return
          k(ea), (N = M.PAN)
      }
      N !== M.NONE &&
        (document.addEventListener('mousemove', A, !1),
        document.addEventListener('mouseup', B, !1),
        I.dispatchEvent(K))
    }
  }
  function A(ea) {
    if (!1 !== I.enabled)
      switch ((ea.preventDefault(), N)) {
        case M.ROTATE:
          if (!1 === I.enableRotate) return
          l(ea)
          break
        case M.DOLLY:
          if (!1 === I.enableZoom) return
          m(ea)
          break
        case M.PAN:
          if (!1 === I.enablePan) return
          n(ea)
      }
  }
  function B(ea) {
    !1 === I.enabled ||
      (o(ea),
      document.removeEventListener('mousemove', A, !1),
      document.removeEventListener('mouseup', B, !1),
      I.dispatchEvent(L),
      (N = M.NONE))
  }
  function C(ea) {
    !1 === I.enabled ||
      !1 === I.enableZoom ||
      (N !== M.NONE && N !== M.ROTATE) ||
      (ea.preventDefault(),
      ea.stopPropagation(),
      I.dispatchEvent(K),
      p(ea),
      I.dispatchEvent(L))
  }
  function D(ea) {
    !1 === I.enabled || !1 === I.enableKeys || !1 === I.enablePan || q(ea)
  }
  function E(ea) {
    if (!1 !== I.enabled) {
      switch ((ea.preventDefault(), ea.touches.length)) {
        case 1:
          if (!1 === I.enableRotate) return
          r(ea), (N = M.TOUCH_ROTATE)
          break
        case 2:
          if (!1 === I.enableZoom && !1 === I.enablePan) return
          s(ea), (N = M.TOUCH_DOLLY_PAN)
          break
        default:
          N = M.NONE
      }
      N !== M.NONE && I.dispatchEvent(K)
    }
  }
  function F(ea) {
    if (!1 !== I.enabled)
      switch ((ea.preventDefault(), ea.stopPropagation(), ea.touches.length)) {
        case 1:
          if (!1 === I.enableRotate) return
          if (N !== M.TOUCH_ROTATE) return
          t(ea)
          break
        case 2:
          if (!1 === I.enableZoom && !1 === I.enablePan) return
          if (N !== M.TOUCH_DOLLY_PAN) return
          u(ea)
          break
        default:
          N = M.NONE
      }
  }
  function G(ea) {
    !1 === I.enabled || (w(ea), I.dispatchEvent(L), (N = M.NONE))
  }
  function H(ea) {
    !1 === I.enabled || ea.preventDefault()
  }
  ;(this.object = a),
    (this.domElement = b === void 0 ? document : b),
    (this.enabled = !0),
    (this.target = new THREE.Vector3()),
    (this.minDistance = 0),
    (this.maxDistance = Infinity),
    (this.minZoom = 0),
    (this.maxZoom = Infinity),
    (this.minPolarAngle = 0),
    (this.maxPolarAngle = Math.PI),
    (this.minAzimuthAngle = -Infinity),
    (this.maxAzimuthAngle = Infinity),
    (this.enableDamping = !1),
    (this.dampingFactor = 0.25),
    (this.enableZoom = !0),
    (this.zoomSpeed = 1),
    (this.enableRotate = !0),
    (this.rotateSpeed = 1),
    (this.enablePan = !0),
    (this.panSpeed = 1),
    (this.screenSpacePanning = !1),
    (this.keyPanSpeed = 7),
    (this.autoRotate = !1),
    (this.autoRotateSpeed = 2),
    (this.enableKeys = !0),
    (this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 }),
    (this.mouseButtons = {
      LEFT: THREE.MOUSE.LEFT,
      MIDDLE: THREE.MOUSE.MIDDLE,
      RIGHT: THREE.MOUSE.RIGHT,
    }),
    (this.target0 = this.target.clone()),
    (this.position0 = this.object.position.clone()),
    (this.zoom0 = this.object.zoom),
    (this.getPolarAngle = function() {
      return P.phi
    }),
    (this.getAzimuthalAngle = function() {
      return P.theta
    }),
    (this.setPolarAngle = function(ea) {
      ;(P.phi = ea), this.forceUpdate()
    }),
    (this.setAzimuthalAngle = function(ea) {
      ;(P.theta = ea), this.forceUpdate()
    }),
    (this.saveState = function() {
      I.target0.copy(I.target),
        I.position0.copy(I.object.position),
        (I.zoom0 = I.object.zoom)
    }),
    (this.reset = function() {
      I.target.copy(I.target0),
        I.object.position.copy(I.position0),
        (I.object.zoom = I.zoom0),
        I.object.updateProjectionMatrix(),
        I.dispatchEvent(J),
        I.update(),
        (N = M.NONE)
    }),
    (this.forceUpdate = (function() {
      var ea = new THREE.Vector3(),
        fa = new THREE.Quaternion().setFromUnitVectors(
          a.up,
          new THREE.Vector3(0, 1, 0)
        ),
        ga = fa.clone().inverse(),
        ha = new THREE.Vector3(),
        ia = new THREE.Quaternion()
      return function() {
        var ja = this.object.position
        ea.copy(ja).sub(this.target),
          ea.applyQuaternion(fa),
          (P.theta = Math.max(
            this.minAzimuthAngle,
            Math.min(this.maxAzimuthAngle, P.theta)
          )),
          (P.phi = Math.max(
            this.minPolarAngle,
            Math.min(this.maxPolarAngle, P.phi)
          )),
          (P.phi = Math.max(O, Math.min(Math.PI - O, P.phi)))
        var ka = ea.length() * R
        return (
          (ka = Math.max(this.minDistance, Math.min(this.maxDistance, ka))),
          this.target.add(S),
          (ea.x = ka * Math.sin(P.phi) * Math.sin(P.theta)),
          (ea.y = ka * Math.cos(P.phi)),
          (ea.z = ka * Math.sin(P.phi) * Math.cos(P.theta)),
          ea.applyQuaternion(ga),
          ja.copy(this.target).add(ea),
          this.object.lookAt(this.target),
          !0 === this.enableDamping
            ? ((P.thetaDelta *= 1 - this.dampingFactor),
              (P.phiDelta *= 1 - this.dampingFactor))
            : ((P.thetaDelta = 0), (P.phiDelta = 0)),
          (R = 1),
          S.set(0, 0, 0),
          (T ||
            ha.distanceToSquared(this.object.position) > O ||
            8 * (1 - ia.dot(this.object.quaternion)) > O) &&
            (ha.copy(this.object.position),
            ia.copy(this.object.quaternion),
            (T = !1),
            !0)
        )
      }
    })()),
    (this.update = (function() {
      var ea = new THREE.Vector3(),
        fa = new THREE.Quaternion().setFromUnitVectors(
          a.up,
          new THREE.Vector3(0, 1, 0)
        ),
        ga = fa.clone().inverse(),
        ha = new THREE.Vector3(),
        ia = new THREE.Quaternion()
      return function() {
        var ka = I.object.position
        return (
          ea.copy(ka).sub(I.target),
          ea.applyQuaternion(fa),
          P.setFromVector3(ea),
          I.autoRotate && N === M.NONE && e(c()),
          (P.theta += Q.theta),
          (P.phi += Q.phi),
          (P.theta = Math.max(
            I.minAzimuthAngle,
            Math.min(I.maxAzimuthAngle, P.theta)
          )),
          (P.phi = Math.max(I.minPolarAngle, Math.min(I.maxPolarAngle, P.phi))),
          P.makeSafe(),
          (P.radius *= R),
          (P.radius = Math.max(
            I.minDistance,
            Math.min(I.maxDistance, P.radius)
          )),
          I.target.add(S),
          ea.setFromSpherical(P),
          ea.applyQuaternion(ga),
          ka.copy(I.target).add(ea),
          I.object.lookAt(I.target),
          !0 === I.enableDamping
            ? ((Q.theta *= 1 - I.dampingFactor),
              (Q.phi *= 1 - I.dampingFactor),
              S.multiplyScalar(1 - I.dampingFactor))
            : (Q.set(0, 0, 0), S.set(0, 0, 0)),
          (R = 1),
          (T ||
            ha.distanceToSquared(I.object.position) > O ||
            8 * (1 - ia.dot(I.object.quaternion)) > O) &&
            (I.dispatchEvent(J),
            ha.copy(I.object.position),
            ia.copy(I.object.quaternion),
            (T = !1),
            !0)
        )
      }
    })()),
    (this.dispose = function() {
      I.domElement.removeEventListener('contextmenu', H, !1),
        I.domElement.removeEventListener('mousedown', z, !1),
        I.domElement.removeEventListener('wheel', C, !1),
        I.domElement.removeEventListener('touchstart', E, !1),
        I.domElement.removeEventListener('touchend', G, !1),
        I.domElement.removeEventListener('touchmove', F, !1),
        document.removeEventListener('mousemove', A, !1),
        document.removeEventListener('mouseup', B, !1),
        window.removeEventListener('keydown', D, !1)
    })
  var I = this,
    J = { type: 'change' },
    K = { type: 'start' },
    L = { type: 'end' },
    M = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_DOLLY_PAN: 4,
    },
    N = M.NONE,
    O = 1e-6,
    P = new THREE.Spherical(),
    Q = new THREE.Spherical(),
    R = 1,
    S = new THREE.Vector3(),
    T = !1,
    U = new THREE.Vector2(),
    V = new THREE.Vector2(),
    W = new THREE.Vector2(),
    X = new THREE.Vector2(),
    Y = new THREE.Vector2(),
    Z = new THREE.Vector2(),
    $ = new THREE.Vector2(),
    _ = new THREE.Vector2(),
    aa = new THREE.Vector2(),
    ba = (function() {
      var ea = new THREE.Vector3()
      return function(ga, ha) {
        ea.setFromMatrixColumn(ha, 0), ea.multiplyScalar(-ga), S.add(ea)
      }
    })(),
    ca = (function() {
      var ea = new THREE.Vector3()
      return function(ga, ha) {
        !0 === I.screenSpacePanning
          ? ea.setFromMatrixColumn(ha, 1)
          : (ea.setFromMatrixColumn(ha, 0), ea.crossVectors(I.object.up, ea)),
          ea.multiplyScalar(ga),
          S.add(ea)
      }
    })(),
    da = (function() {
      var ea = new THREE.Vector3()
      return function(ga, ha) {
        var ia = I.domElement === document ? I.domElement.body : I.domElement
        if (I.object.isPerspectiveCamera) {
          var ja = I.object.position
          ea.copy(ja).sub(I.target)
          var ka = ea.length()
          ;(ka *= Math.tan(((I.object.fov / 2) * Math.PI) / 180)),
            ba((2 * ga * ka) / ia.clientHeight, I.object.matrix),
            ca((2 * ha * ka) / ia.clientHeight, I.object.matrix)
        } else
          I.object.isOrthographicCamera
            ? (ba(
                (ga * (I.object.right - I.object.left)) /
                  I.object.zoom /
                  ia.clientWidth,
                I.object.matrix
              ),
              ca(
                (ha * (I.object.top - I.object.bottom)) /
                  I.object.zoom /
                  ia.clientHeight,
                I.object.matrix
              ))
            : (console.warn(
                'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.'
              ),
              (I.enablePan = !1))
      }
    })()
  I.domElement.addEventListener('contextmenu', H, !1),
    I.domElement.addEventListener('mousedown', z, !1),
    I.domElement.addEventListener('wheel', C, !1),
    I.domElement.addEventListener('touchstart', E, !1),
    I.domElement.addEventListener('touchend', G, !1),
    I.domElement.addEventListener('touchmove', F, !1),
    window.addEventListener('keydown', D, !1),
    this.update()
}),
  (THREE.OrbitControls.prototype = Object.create(
    THREE.EventDispatcher.prototype
  )),
  (THREE.OrbitControls.prototype.constructor = THREE.OrbitControls),
  Object.defineProperties(THREE.OrbitControls.prototype, {
    center: {
      get: function get() {
        return (
          console.warn(
            'THREE.OrbitControls: .center has been renamed to .target'
          ),
          this.target
        )
      },
    },
    noZoom: {
      get: function get() {
        return (
          console.warn(
            'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.'
          ),
          !this.enableZoom
        )
      },
      set: function set(a) {
        console.warn(
          'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.'
        ),
          (this.enableZoom = !a)
      },
    },
    noRotate: {
      get: function get() {
        return (
          console.warn(
            'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.'
          ),
          !this.enableRotate
        )
      },
      set: function set(a) {
        console.warn(
          'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.'
        ),
          (this.enableRotate = !a)
      },
    },
    noPan: {
      get: function get() {
        return (
          console.warn(
            'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.'
          ),
          !this.enablePan
        )
      },
      set: function set(a) {
        console.warn(
          'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.'
        ),
          (this.enablePan = !a)
      },
    },
    noKeys: {
      get: function get() {
        return (
          console.warn(
            'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.'
          ),
          !this.enableKeys
        )
      },
      set: function set(a) {
        console.warn(
          'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.'
        ),
          (this.enableKeys = !a)
      },
    },
    staticMoving: {
      get: function get() {
        return (
          console.warn(
            'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.'
          ),
          !this.enableDamping
        )
      },
      set: function set(a) {
        console.warn(
          'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.'
        ),
          (this.enableDamping = !a)
      },
    },
    dynamicDampingFactor: {
      get: function get() {
        return (
          console.warn(
            'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.'
          ),
          this.dampingFactor
        )
      },
      set: function set(a) {
        console.warn(
          'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.'
        ),
          (this.dampingFactor = a)
      },
    },
  })
